<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Tryton | Pritish Chakraborty]]></title>
  <link href="http://PritishC.github.io/blog/categories/tryton/atom.xml" rel="self"/>
  <link href="http://PritishC.github.io/"/>
  <updated>2016-02-14T21:01:33+05:30</updated>
  <id>http://PritishC.github.io/</id>
  <author>
    <name><![CDATA[Pritish Chakraborty]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Tryton Module Basics and Programming Example]]></title>
    <link href="http://PritishC.github.io/blog/2014/11/02/tryton-module-basics-and-programming-example/"/>
    <updated>2014-11-02T19:22:17+05:30</updated>
    <id>http://PritishC.github.io/blog/2014/11/02/tryton-module-basics-and-programming-example</id>
    <content type="html"><![CDATA[This article will cover the basics of developing a module for Tryton. After having
gone through the setup, it is finally time to make your own module. This might
turn out to be a longer post than all my previous ones, so hang in there.

*Note*: This article is to some extent *deprecated* - it was written with Tryton
v3.2 in mind.

<!--more-->

## Introduction

I will use the [module](https://github.com/PritishC/nereid-erms/tree/develop) I developed as part of an initial assignment to explain. 
The Tryton [documentation](http://docs.tryton.org/) tells us that the basic 
components of a Tryton module are its models and its views.

The models define the backend of the application. Much like in any other ORM, they
will map to tables in a database, which in this case is controlled by the Postgres
server. The views are written in XML and they define what the user sees in the
Tryton client. Views can even be inherited and this makes for a very clever design -
_it supports reusability_.

Each model can have a set of fields - similar to that of a table in a DB. The fields can have types such as Integer, Char, Text, etc. as well as special relationship
types such as Many2One and One2Many. Refer the docs for more information.

Each view is defined in the view directory and these views are brought together
in a ModelName.xml file which is at the project&#8217;s root.

Now suppose we wish to build an Employee Record Management system in Tryton. The
first thing to do is to design the models, and then we would go about designing
the views. I designed models for an Employee, a Department and a Designation.

## The Models

One may choose to have a model be stand-alone or be &#8216;part&#8217; of another model.
Tryton also has an easy mechanism for models which need to be customized in down-
stream modules, similar to inheritance. For example, I know that the Employee
model is already present in Tryton with the `__name__` set as `company.employee`. 
I wish to customize this model and I have done so as follows -:

{% include_code employee.py lang:python erms/employee.py %}

There&#8217;s a lot going on here, so let&#8217;s take it step by step. We can see two models
that we wish to be in the Employee &#8216;namespace&#8217;, `Employee` and `Designation`.
If you think about it, after all, it is an employee who has a designation!

Our first field in `Employee` is a selection field - the user can select from the
options that we present to them. The options are written as a list of two-tuples.
Each two-tuple is of the format `(option_name, option_string)`.

The other options provided to the field type constructor are the name of the field
to be displayed, the option of making the field mandatory or required, the possible
states of the field and other fields that this one may depend on. We&#8217;ll get to
`states` and `depends` in a moment.

The next field is an interesting one - it defines a many to one relationship to
the `Department` model. This means that multiple employees can belong to a single
department. The constructor arguments are quite simple to grasp - the `__name__`
of the model being related with, the string to be displayed, and so on.

The third field - `designation` - is very similar to `department`. The only difference 
here is that we have also set a domain argument. Domains are lists of three-tuples
that can be used to form a particular selection over the records of a model.
In this case, we wish to comb through the records of a designation and select
those which belong to the department specified by the field `department`.`Eval`
is a PYSON statement which gives us a boolean value. Domains are used alot when 
searching records, and they contain [`PYSON`](http://doc.tryton.org/3.4/trytond/doc/topics/pyson.html#topics-pyson) statements.

Since we have just covered PYSON, we may as well check out those global variables
now - `STATES` and `DEPENDS`. The former is a dict whose keys are state names,
and whose values are PYSON statements. In this case, the `readonly` state is
activated if we find that the `active` field of the model has been set to false.

The rest of the fields are simple Char fields and I shall not cover them in detail.

Let us come down to the remaining parts of the `Employee` class. `_sql_error_messages`
is a dict whose keys are names of error messages and whose values are the strings
to be displayed in case such an error occurs. `_unique` is a list of three-tuples
which define some uniqueness constraints on the model table.

The `__setup__` method is an incredibly useful classmethod. Note how I am updating
the `party` and `company` fields of our custom Employee class (these fields are
present in the parent Employee model, and thus, need to have their `states` and
`depends` set, for which I have made a method) here - these fields need not be
rewritten here. I am also setting the SQL constraints of the table here. All sorts
of field updation and customization can be done in `__setup__`.

The `default` methods are pretty self-explanatory - they return default values
for a field. We also have methods such as `on_change` and `on_change_with` -
they are quite interesting and one should browse the docs to see what they do.

Let&#8217;s cover one more model class - `Department`. It has a Many2One field relating 
it to the `Company` class. One may check that out here -:

{% include_code company.py lang:python erms/company.py %}

Note how model classes that are new to the hierarchy have to specifically inherit
from classes such as `ModelSQL`, but classes which are already present and are
being customized - such as `Employee` - need not have this explicit inheritance.
The `__name__` field does this magic for us.

Now the `Department` is a part of the `Company` model. It has a Many2One field
relating it to `Company`. How must we obtain the company that this department
is associated with, or more precisely, the _active record_ of the `Company` model,
for our default method?

We do so by looking for it in the transaction context. `context` is a dict which
has such keys.

And that wraps up model basics! Let us now move to views.

## The Views

Let&#8217;s check out the view for our `Employee` model. The root xml is as follows -:

{% include_code employee.xml lang:xml erms/employee.xml %}

Views can be of two main types - tree and form. Form views are used to enter 
data while tree views are used to display them. The first two record tags deal 
with, in a sense, instances of the model class with the `__name__` `ir.ui.view`. 
The first is for a tree and the second for a form. Note how they are inheriting 
from tree and form views which are already present in the parent Employee model.

The `menuitem` tag allows us to create a new menu item for an existing menu. In
this case, we add `Employees` to the `Party` menu. `company.act_employee_form` is
predefined in the parent model and we need not worry about defining it. act stands
for &#8220;action&#8221;, and the action here is to open the form view.

We may have to define our form and tree views separately, especially if they are
inheriting from a parent model, to add any extra details, or just to create from
scratch. For example, here are the form and tree views which were defined in the
employee xml -:

{% include_code form view lang:xml erms/view/employee_form.xml %}

{% include_code tree view lang:xml erms/view/employee_tree.xml %}

These views use the newer xpath syntax that the Tryton community has incorporated.
In effect, the xpath statement here tells Tryton to put our custom Employee fields
after the company field. The active field is designated as a checkbox by putting
it in a group for checkboxes.
The `notebook` tag allows one to create tabs in the form view which can be used
to categorize or classify details according to some criterion. Notebooks have
pages which contain fields in a particular category. For example, we have two pages - 
`General Details` and `Personal Details`. The form view needs a label to show in
Tryton for each field name. The tree view needs no such thing.

Also, note how the `designation` and `department` fields are defined as selection
widgets. They will appear as drop-down menus in Tryton, and the values in these
menus will correspond to the list of active records for the `Designation` and
`Department` models, if the user has created any. I would recommend checking out
the other views at my project&#8217;s github page. 

Now we are left with module boilerplate and installation.

## Module Installation

We have the raw materials for our Tryton module - but we still have no idea how
to set things up and finally install the module. My colleagues over at the company
have created a nifty command-line application which automates the process - it
can be found [here](https://github.com/openlabs/trytond-cookiecutter).

In your project&#8217;s root directory, clone the cookiecutter module as is given in
the readme. We will be prompted to enter project configuration details, and these
may be changed anytime by modifying `cookiecutter.json`.

Once this is done, we can install our Tryton module&#8217;s various dependencies and 
write the module to the `trytond/modules` directory by running the following
command - `python setup.py install`. We have our Tryton database which we created
earlier - we shall install the module using this DB.

&#8220;` bash installing your module
$ trytond -c path/to/trytond.conf -i module_name -d db_name
&#8220;`

One should replace module_name with &#8216;all&#8217; for first time installation. The -i
option can be replaced with -u to update a particular module. Module updation is
usually done when we change or add a model(s) in that module.

And now we should have a fully functional module in Tryton. Check it out by running
the Tryton client. 

I hope everyone enjoyed reading this post as much as I did writing it. Until
next time then.

<div id="discourse-comments"></div>
<script type="text/javascript">
  var discourseUrl = "",
      discourseEmbedUrl = "http://PritishC.github.io/blog/2014/11/02/tryton-module-basics-and-programming-example/";

  (function() {
    var d = document.createElement('script'); d.type = 'text/javascript'; d.async = true;
      d.src = discourseUrl + 'javascripts/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(d);
  })();
</script>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Beginning Tryton]]></title>
    <link href="http://PritishC.github.io/blog/2014/10/21/beginning-tryton/"/>
    <updated>2014-10-21T12:05:18+05:30</updated>
    <id>http://PritishC.github.io/blog/2014/10/21/beginning-tryton</id>
    <content type="html"><![CDATA[Before we go through the setup of the Tryton client and server, one should go
through setting up the [virtualenv]({% post_url 2014-10-16-virtualenv-setup-for-tryton %})
and [postgres]({% post_url 2014-10-19-postgres-setup %}).
Also, install `libxslt-dev` (and perhaps `libz-dev` as well) with your package 
manager because the `lxml` package needs it.

<!--more-->

Right, now let&#8217;s activate our virtualenv and install the requisite packages.

&#8220;` bash installing tryton/trytond
$ workon trytonenv
$ pip install trytond trytond-party trytond-company trytond-country trytond-currency
$ pip install tryton
$ pip install psycopg2 # Required for DB connectivity.
&#8220;`

The packages that follow `trytond` are Tryton modules. `trytond` is the server
and `tryton` is the client. Any server needs a configuration file, and we have
one for ours too. Picked up from the Gentoo wiki -:

{% include_code sample trytond.conf lang:text trytond.conf %}

You might want to change the value of the `db_password` field there, to the pass
that you had set for the postgres role earlier. You will be using this pass to
login to a database in Tryton.

Now, fire up two terminal windows or tabs, and run the following commands separately
in each -:

&#8220;` bash tryton start
$ trytond -c path/to/trytond.conf
$ tryton -dv
&#8220;`

The `-dv` switch will allow you to see errors and other messages on the command
line for the Tryton client in a verbose manner.

You will arrive at a screen to login to the demo profile. Close that, and head
to File->Database->New Database. Note that the default administrator password
for Tryton is `admin`. Here, the `admin_passwd` field has been inserted to change
the default. One could remove this field if they wished.

<img src="{{ root_url }}/images/tryton-createdb.png" />

Congratulations, you&#8217;ve created your very first Tryton database. Now you can login
to it and install the necessary Tryton modules.

<div id="discourse-comments"></div>
<script type="text/javascript">
  var discourseUrl = "",
      discourseEmbedUrl = "http://PritishC.github.io/blog/2014/10/21/beginning-tryton/";

  (function() {
    var d = document.createElement('script'); d.type = 'text/javascript'; d.async = true;
      d.src = discourseUrl + 'javascripts/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(d);
  })();
</script>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Postgres Setup]]></title>
    <link href="http://PritishC.github.io/blog/2014/10/19/postgres-setup/"/>
    <updated>2014-10-19T20:27:55+05:30</updated>
    <id>http://PritishC.github.io/blog/2014/10/19/postgres-setup</id>
    <content type="html"><![CDATA[This article offers a simple introduction to PostgreSQL and how to install it.
It is necessary for Tryton. In effect, this article is merely filler, and one can
skip it if one wishes so.

<!--more-->

[PostgreSQL](http://www.postgresql.org/) is an open-source ORDBMS which is a hardcore
programmer&#8217;s paradise. Since it is community-developed, it adheres to strict standards
and supports DB best practices. For more information, Google is your friend.

Now the installation of Postgres on your setup depends on the operating system you
have installed. For most Linux distros, Postgres has a distro-specific bundle which
can easily be installed using the particular package manager. It is usually advised 
to install this distro-specific bundle rather then going down the generic route.

I had faced several problems setting up Postgres on Linux Mint because I downloaded
and executed the generic bundle. You can find some mention of those problems here 
at the [wiki](https://github.com/PritishC/nereid-erms/wiki) of a project which I 
wrote as part of a company induction task. I am currently on Lubuntu, and this 
time, I used the package manager. Lesson learned.

Another thing you ideally should do is install [PGAdmin](http://www.pgadmin.org/). 
It is a very useful tool for management and administration of your databases. You
might often have to view a specific table inside the DB that you create for Tryton.

For Debian derivatives such as mine, 

&#8220;` bash bash snippet
$ sudo apt-get install postgresql postgresql-contrib
$ sudo apt-get install pgadmin3
&#8220;`

There is also the `postgres` user setup. After one is done installing the above,
one should fire up a terminal and set the `postgres` user&#8217;s password.

&#8220;` bash postgres user
$ sudo -u postgres psql postgres
$ \password postgres
&#8220;`

Equivalently, one could do `sudo su - postgres` to get into the postgres account,
and then run `psql -u postgres -h localhost` or something similar.
The second line in the above snippet sets a password for the postgres database 
role.

And that&#8217;s that. Soon, we shall be on a functioning Tryton setup!


<div id="discourse-comments"></div>
<script type="text/javascript">
  var discourseUrl = "",
      discourseEmbedUrl = "http://PritishC.github.io/blog/2014/10/19/postgres-setup/";

  (function() {
    var d = document.createElement('script'); d.type = 'text/javascript'; d.async = true;
      d.src = discourseUrl + 'javascripts/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(d);
  })();
</script>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Virtualenv Setup for Tryton]]></title>
    <link href="http://PritishC.github.io/blog/2014/10/16/virtualenv-setup-for-tryton/"/>
    <updated>2014-10-16T22:31:26+05:30</updated>
    <id>http://PritishC.github.io/blog/2014/10/16/virtualenv-setup-for-tryton</id>
    <content type="html"><![CDATA[In this post, we shall learn how to setup a virtualenv for Tryton. Any new developer
who wishes to develop on Tryton needs to know a few basic things.

<!--more-->

Tryton is not for the faint-hearted. A new person can possibly take a long time to get adjusted
to the workflow.

* Have pip/setuptools ready. Use your package manager to get pip (apt, pacman, emerge
  etc).
* Install virtualenvwrapper. It is essential for any serious Python developer.
  Follow the steps given in the virtualenvwrapper [docs](http://virtualenvwrapper.readthedocs.org/en/latest/install.html)
  to setup everything - thing such as the `WORKON_HOME` variable.
* Now, before you make a virtualenv, make absolutely sure that you have a minimal
  set of site packages. Site packages are those Python packages that have been
  installed system-wide. Here is a list of packages that I have (via `pip freeze`) -:

  &#8220;` bash global pip freeze
  CDApplet==1.0
  CDBashApplet==1.0
  Cython==0.20.1post0
  apt-xapian-index==0.45
  arandr==0.1.7.1
  argparse==1.2.1
  chardet==2.0.1
  colorama==0.2.5
  defer==1.0.6
  gyp==0.1
  html5lib==0.999
  mercurial==2.8.2
  psutil==1.2.1
  pycups==1.9.66
  pycurl==7.19.3
  pygobject==3.12.0
  pysmbc==1.0.14.1
  pysqlite==2.6.3
  python-apt==0.9.3.5
  python-debian==0.1.21-nmu2ubuntu2
  python-sql==0.3
  pyxdg==0.25
  requests==2.2.1
  six==1.8.0
  stevedore==1.0.0
  urllib3==1.7.1
  virtualenv==1.11.6
  virtualenv-clone==0.2.5
  virtualenvwrapper==4.3.1
  wsgiref==0.1.2
  &#8220;`
* One particular package that you will find to give you headaches during the installation
  is `pygtk`. This package cannot be installed via pip. Why? Because screw you, that&#8217;s why.
  Now you have two options.
  + Follow the steps given [here](https://gist.github.com/ches/1094799) to install `pygtk` 
    inside a virtualenv. However, you will find that doing this over and over again would
    be tedious.
  + What about the package that has been installed system-wide? Could we possibly use it?
    Well, it turns out we can! The next step details on this method.  
    PS: If you don&#8217;t have it installed system-wide, do it bruh. Use your favorite package manager,
    I&#8217;m not judgin&#8217;.
* If you listened to me two steps ago and didn&#8217;t fall asleep - the reason I said that
  one must keep a minimal set of site packages is because these shall be incorporated
  into the virtualenv. These are the absolute bare-minimum requirements that every
  virtualenv will get. Now issue the following command in your terminal, in whichever
  directory you&#8217;ve readied for this purpose -:

  &#8220;` bash [virtualenv]
  mkproject myenv
  &#8220;`

  Substitute myenv with any name you wish. And voila, you have your newly commissioned
  virtualenv.
* After the virtualenv is created, use the `toggleglobalsitepackages` switch from inside
  it to enable pygtk. Since pygtk was installed system-wide (global site packages), it gets
  incorporated into your virtualenv and you don&#8217;t have to bother about it.

* What this does is create a project folder at the location specified by the `$PROJECT_HOME`
  variable, which you must have specified during your virtualenvwrapper installation. You can
  now clone your GitHub/etc repositories inside this folder and install their requirements.

* This kind of project organization allows you to easily clone the repositories
  which constitute the requirements of a particular repository and make changes in them.
  For example, `nereid-webshop` depends on `nereid-cart-b2c`. If you need to send a patch
  on the latter, you can clone it inside the project folder you created for webshop.

And that&#8217;s that folks! In the next post, we shall set up Postgres as Tryton uses
Postgres databases. Following that, we shall learn how to actually install Tryton, 
both the client and the server.
  


<div id="discourse-comments"></div>
<script type="text/javascript">
  var discourseUrl = "",
      discourseEmbedUrl = "http://PritishC.github.io/blog/2014/10/16/virtualenv-setup-for-tryton/";

  (function() {
    var d = document.createElement('script'); d.type = 'text/javascript'; d.async = true;
      d.src = discourseUrl + 'javascripts/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(d);
  })();
</script>
]]></content>
  </entry>
  
</feed>
