<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Nereid | Pritish Chakraborty]]></title>
  <link href="http://PritishC.github.io/blog/categories/nereid/atom.xml" rel="self"/>
  <link href="http://PritishC.github.io/"/>
  <updated>2016-02-14T21:01:33+05:30</updated>
  <id>http://PritishC.github.io/</id>
  <author>
    <name><![CDATA[Pritish Chakraborty]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Analyzing Stuff With Google Analytics]]></title>
    <link href="http://PritishC.github.io/blog/2015/03/08/analyzing-stuff-with-google-analytics/"/>
    <updated>2015-03-08T12:37:36+05:30</updated>
    <id>http://PritishC.github.io/blog/2015/03/08/analyzing-stuff-with-google-analytics</id>
    <content type="html"><![CDATA[This article offers a glimpse into how we implemented Google Analytics procedures,
such as click tracking, in our generic webstore - [Nereid Webshop](https://github.com/openlabs/nereid-webshop).

<!--more-->

As a beginner in Javascript, I was tasked with tracking clicks from various areas
of the webstore, such as product pages, the search page, etc. Google&#8217;s developer
documentation ([here](https://developers.google.com/analytics/)) is a good place
to start. Note that we used the more recent ga.js, as opposed to the older
analytics.js script.

First we wrote our backend implementation - to fetch the details of a product.
The basic Product model is in the core [Product](https://github.com/tryton/product) repository.
We added a few attributes of our own in our own repos.

&#8220;` python ga data method
def ga_product_data(self, **kwargs):
    &#8221;&#8217;
    Return a dictionary of the product information as expected by Google
    Analytics
    Other possible values for kwargs include -:
    :param list: The name of the list in which this impression is to be
                 recorded
    :param position: Integer position of the item on the view
    &#8221;&#8217;
    rv = {
        &#8216;id&#8217;: self.code or unicode(self.id),
        &#8216;name&#8217;: self.name,
        &#8216;category&#8217;: self.category and self.category.name or None,
    }
    rv.update(kwargs)
    return rv
&#8220;`

Once we had that in place, we began by analyzing what parts of our webstore needed
analytics. A typical product page contains various link-points where we could
insert our GA attributes. Some of these could be -:

* Add to cart button
* Related product links
* Add related products to cart button

For example, in our form for adding the product to cart -:

{% raw %}
&#8220;` html add to cart
<form action="{{ url_for("nereid.cart.add_to_cart") }}" method="post" id="product-buy-now" class="add-to-cart" autocomplete="off" data-ga-event-label="Add To Cart" data-ga-product-name="{{ product.name }}" data-ga-product-category="{{ product.category and product.category.name or None }}" data-ga-product-price="{{ product.sale_price()|currencyformat(request.nereid_currency.code) }}">
  <input type="hidden" name="csrf_token" value="{{ csrf_token() }}" />
  <input type="hidden" name="quantity" value="1"/>
  <input type="hidden" name="size" id="size-id"/>
  <input type="hidden" name="product" value="{{ product.id }}"/>
  <input type="hidden" name="action" value="add"/>
  <button class="btn btn-primary btn-buynow btn-block btn-lg" type="submit" {% if not product.can_buy_from_eshop() %}disabled{% endif %}
    quantity="1" id="buy-now-btn">Buy Now</button>
</form>
&#8220;`
{% endraw %}

Similarly, we could have the following on a product link -:

{% raw %}
&#8220;` html product link
<a href="{{ related_product.get_absolute_url() }}" ga-product-link data-ga-product-list="Related Products" data-ga-event-label="Product Thumbnail" data-ga-product-id="{{ related_product.id }}" data-ga-product-name="{{ related_product.name }}" data-ga-product-category="{{ related_product.category and related_product.category.name or None }}">
  <img src="{{ CDN }}{{ related_product.default_image.transform_command().thumbnail(200, 200, 'a') }}" class="img margin-auto" alt="{{ related_product.name }}">
</a>
&#8220;`
{% endraw %}

Note the `data-ga` prefixed attributes in the `form` tag. These are used in
conjunction with jQuery&#8217;s data() method to fetch product attributes, to be sent
to Google&#8217;s servers.

The JS snippet for tracking product clicks is as follows (assuming GA is set up already) -:

&#8220;` javascript product click
$(function (){
  $(&#8216;a[href][ga-product-link]&#8217;).on(&#8220;click&#8221;, function(e){
    if(typeof ga == &#8216;undefined&#8217;){
      return true;
    }
    e.preventDefault();
    e.stopPropagation();
    var url = $(this).attr(&#8216;href&#8217;);
    // register safety net timeout:
    var t = setTimeout(function() {
      document.location.href = url
    }, 500);
    ga(&#8216;ec:addProduct&#8217;, {
      &#8216;id&#8217;: $(this).data(&#8216;ga-product-id&#8217;),
      &#8216;name&#8217;: $(this).data(&#8216;ga-product-name&#8217;),
      &#8216;category&#8217;: $(this).data(&#8216;ga-product-category&#8217;)
    });
    ga(&#8216;ec:setAction&#8217;, &#8216;click&#8217;, {list: $(this).data(&#8216;ga-product-list&#8217;)});
    ga(&#8216;send&#8217;, &#8216;event&#8217;, &#8216;Product&#8217;, &#8216;click&#8217;, $(this).data(&#8216;ga-event-label&#8217;) || &#8221;, {
      &#8216;hitCallback&#8217;: function() {
        clearTimeout(t);
        // redirect anyway:
        document.location.href = url;
      }});
  });
});
&#8220;`

I&#8217;ll break this down step by step -:

* First, we collect all those anchor tags on the page which have the `ga-product-link` attribute.
  We register our method on the click event.
* We need `preventDefault()` and `stopPropagation()` to temporarily disable default behaviour,
  i.e., taking us to a different page.
* We register a **safety net timeout**. This step is crucial - we don&#8217;t want our page
  loading to take forever or never happen just because the data wasn&#8217;t sent to the
  GA servers successfully.
* We perform a `addProduct` call with product details and then use `setAction`
  to denote that this was a product click - and send data describing the event -
  which in this case was a click on a related product.
* We also register a callback which clears our earlier timeout and redirects to
  the desired location. This is in the normal case - that the data was sent successfully.
  If the data isn&#8217;t sent, the redirect is done on timeout completion.

Tracking product additions to cart was slightly trickier. We need to take care of
form submission in the add to cart case.

&#8220;` javascript add to cart
$(function() {
  $(&#8216;.add-to-cart&#8217;).submit(function(e){
    if(typeof ga == &#8216;undefined&#8217;){
      return true;
    }
    e.preventDefault();
    var alreadySubmitted = false;
    var form = this;
    /* The code below registers a timeout which acts
     * as a safety net. The boolean alreadySubmitted is used
     * to check whether the form was already submitted or not.
     * It is used by the callbacks in setTimeout and GA. It is to
     * avoid the specific cases where both callbacks fire, resulting
     * in a double form submission.
     */
    var t = setTimeout(function() {
      if (alreadySubmitted) return;
      alreadySubmitted = true;
      form.submit();
    }, 500);
    ga(&#8216;ec:addProduct&#8217;, {
      &#8216;id&#8217;: $(this).children(&#8220;input[name=&#8217;product&#8217;]&#8221;).attr(&#8216;value&#8217;),
      &#8216;name&#8217;: $(this).data(&#8216;ga-product-name&#8217;),
      &#8216;category&#8217;: $(this).data(&#8216;ga-product-category&#8217;),
      &#8216;price&#8217;: $(this).data(&#8216;ga-product-price&#8217;),
      &#8216;quantity&#8217;: $(this).children(&#8220;input[name=&#8217;quantity&#8217;]&#8221;).attr(&#8216;value&#8217;),
    });
    ga(&#8216;ec:setAction&#8217;, &#8216;add&#8217;);
    ga(&#8216;send&#8217;, &#8216;event&#8217;, &#8216;CartAnalytics&#8217;, &#8216;click&#8217;, $(this).data(&#8216;ga-event-label&#8217;) || &#8221;, {
      &#8216;hitCallback&#8217;: function() {
        if (alreadySubmitted) return;
        alreadySubmitted = true;
        // Submit anyway
        form.submit();
      }});
  });
});
&#8220;`

In this case, nearly everything is the same, except the use of a boolean - `alreadySubmitted`.
This boolean is checked in both cases - when the data is sent succesfully to the GA servers,
and when it is not and form submission should not be delayed, and *also* to prevent
a double form submission - an edge case which I was able to consistently reproduce.

We also implemented product removal from cart in a similar manner. You can peruse
the webshop source at your leisure - it is open-source, and we encourage good pull requests.

My next article will be on one of my favourite tools - Elasticsearch :-).

<div id="discourse-comments"></div>
<script type="text/javascript">
  var discourseUrl = "",
      discourseEmbedUrl = "http://PritishC.github.io/blog/2015/03/08/analyzing-stuff-with-google-analytics/";

  (function() {
    var d = document.createElement('script'); d.type = 'text/javascript'; d.async = true;
      d.src = discourseUrl + 'javascripts/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(d);
  })();
</script>
]]></content>
  </entry>
  
</feed>
